<!-- <div id="smoke-bkg" class="fixed top-0 h-full w=full bg- -z-10"></div>

<script>
    import * as THREE from 'three'

    const $bkg = document.getElementById('smoke-bkg')

    let w = window.innerWidth
    let h = window.innerHeight

    const scene = new THREE.Scene()

    const camera = new THREE.PerspectiveCamera(75, w / h, 1, 1000)
    camera.position.z = 10
    scene.add(camera)

    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(w, h)

    renderer.setClearColor(0xfffafa, 1)

    $bkg?.appendChild(renderer.domElement)

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombra suave


    const light = new THREE.DirectionalLight(0xfffafa, 1);
    light.position.set(0, 3, 2);
    scene.add(light);

    const ambientLight = new THREE.AmbientLight(0xfffafa, 0.5); 
    scene.add(ambientLight);

    light.castShadow = true;
    light.shadow.mapSize.width = 1024; // Mayor resolución para suavizar
    light.shadow.mapSize.height = 1024;
    light.shadow.radius = 9; // Ajusta el radio de suavidad


    const smokeParticle:THREE.Mesh[] = []

    const loader = new THREE.TextureLoader()
    loader.crossOrigin = ""

    loader.load('images/bg2.png', (texture) => {
        const smokeGeo = new THREE.PlaneGeometry(100, 100)

        const smokeMaterial = new THREE.MeshLambertMaterial({
            map: texture,
            transparent: true,
            color: 0xe30052,
            opacity: 0.8,
            blending: THREE.NormalBlending, 
        })

        const NUM_OF_PARTICLES = 100
        for (let p = 0; p < NUM_OF_PARTICLES; p++) {
            const particle = new THREE.Mesh(smokeGeo, smokeMaterial);

            // Ajuste de posiciones para que las partículas solo estén en las orillas
            const edgePadding = 200; // Controla qué tan lejos están las partículas del borde

            // Generar posición en x e y con un rango restringido
            const x = Math.random() > 0.5 
                ? Math.random() * edgePadding - edgePadding / 2 // Lado izquierdo o derecho
                : Math.random() * (1000 - edgePadding) - (1000 - edgePadding) / 2;

            const y = Math.random() > 0.5 
                ? Math.random() * edgePadding - edgePadding / 2 // Parte superior o inferior
                : Math.random() * (500 - edgePadding) - (500 - edgePadding) / 2;

            particle.position.set(
                x,               // x
                y,               // y
                Math.random() * 1000 - 100 // z (sin cambios, mantiene profundidad)
            );

            particle.rotation.z = Math.random() * 360;

            scene.add(particle);
            smokeParticle.push(particle);
        }

    })

    function resize() {
        w = window.innerWidth
        h = window.innerHeight

        camera.aspect = w / h
        camera.updateProjectionMatrix()
        renderer.setSize(w, h)
    }

    function animate() {
        requestAnimationFrame(animate)
    
        smokeParticle.forEach(particle => {
            particle.rotation.z += 0.0009
        })

        renderer.render(scene, camera)
    }

    animate()

    window.addEventListener("resize", resize)

</script> -->